/* mnist testing program in c++ by @menascii
     
   compile:
      g++ testing_mnist.cpp
    
   run:
      ./a.out  

   input:      
   	  hardcoded file name for neural network model weights
		generated by executing training_mnist.cpp

      hardcoded file name for 10,000 mnist testing images
      hardcoded file name for 10,000 mnist testing labels
      download training data from http://yann.lecun.com/exdb/mnist/
        t10k-images-idx3-ubyte.gz
        t10k-labels-idx1-ubyte.gz
        
        unzip and rename accordingly for hardcoded filename values
   
   output:
     	print wrong digit predictions
     	print total correct results percentage and cost

      !!!!!! wrong prediction !!!!!!
      ####### testing digit #######
      mnist testing image #: 2810
      ............................
      ............................
      ............................
      ............................
      ............................
      ..........@@@@@@@@@.........
      ..........@@@@@@@@@@........
      .........@@@@@@@@@@@........
      .........@@@@@@@@@@.........
      .........@@@@@@@@@@.........
      .........@@@@@@@@@@@........
      ........@@@@@@@@@@@@@.......
      ........@@@@@@@@@@@@@.......
      ........@@@......@@@@.......
      .................@@@@@......
      ..................@@@@......
      ..................@@@@......
      ........@@........@@@@......
      .......@@@@......@@@@@......
      .......@@@@@...@@@@@@.......
      .......@@@@@@@@@@@@@@.......
      .......@@@@@@@@@@@@@........
      ........@@@@@@@@@@@.........
      .........@@@@@@@@...........
      .........@@@@@@@............
      ............................
      ............................
      ............................

      expected value:  5
      predicted value: 3
      cost error:      0.478307

      #############################
      correct predictions: 6532 / 10000 = 65.32%
      
   note:
      this program can be executed while training_mnist.cpp is
      executing. it will use the current weights written to the shared
      model weights file.
*/

#include <iostream>
#include <fstream>
#include <cmath>

using namespace std;

void read_headers(ifstream &image, ifstream &label);
void init_layers(double *&layer_one, double *&layer_two, double *&layer_three);
void read_weights(string file_name, double **&layer_one_weights, double **&layer_two_weights);
void read_image(ifstream &image, ifstream &label, int image_digit[28][28], double *layer_one, double expected[], int &image_label);
void get_digit(ifstream &image, int image_digit[28][28], double *layer_one);
void print_digit(int image_digit[28][28]);
void get_label(ifstream &label, double expected[], int &image_label);
void testing_process(double *layer_one, double *layer_two, double *layer_three, double **layer_one_weights, double **layer_two_weights, int &predict);
void perceptron(double *layer_one, double *layer_two, double *layer_three, double **layer_one_weights, double **layer_two_weights);
void cost_value(double *layer_three, double expected[], double &cost_error);
double sigmoid(double x);


int main() 
{
  // mnist binary testing digits file name 
  string testing_images = "test-images";
  // mnist binary testing labels 
  string testing_labels = "test-labels";
  // input weights file name
  string model_weights = "model-weights";

  ifstream testing_image;
  ifstream testing_label;

  int predict;
  int correct;
  double percentage;
  double cost_error;

  // mnist image digit 28 x 28                              
  int image_digit[28][28];
  int image_label;
  // expected value as output array
  // value in array is 7
  // {0, 0, 0, 0, 0, 0, 0, 1, 0, 0}
  double expected[10];

  // neural network layers
  double *layer_one, *layer_two, *layer_three;
  // neural network weights
  double **layer_one_weights, **layer_two_weights;

  // open mnist testing images
  testing_image.open(testing_images.c_str(), ios::in | ios::binary);
  // open mnist testing labels
  testing_label.open(testing_labels.c_str(), ios::in | ios::binary );
  // read headers from training images and labels
  read_headers(testing_image, testing_label);

  // initialize neural network layers
  init_layers(layer_one, layer_two, layer_three);
		
  // read output model weights generated from training_mnist.cpp
  read_weights(model_weights, layer_one_weights, layer_two_weights);
  
  cout << "testing mnist dataset only wrong predictions will be displayed" << endl;
  correct = 0;
  for (int image_index = 0; image_index < 10000; image_index++)
  {
  	// read image and label
  	// assign each 28*28 pixel to first layer as 784 activations in neural network
  	read_image(testing_image, testing_label, image_digit, layer_one, expected, image_label);

  	testing_process(layer_one, layer_two, layer_three, 
                 		layer_one_weights, layer_two_weights, predict);

	cost_value(layer_three, expected, cost_error);

	if (image_label != predict) 
	{
		cout << "!!!!!! wrong prediction !!!!!!" << endl;
		cout << "####### testing digit #######" << endl;
    		cout << "mnist testing image #: " << image_index << endl; 
		// print mnist 28x28 mnist digit and label
		print_digit(image_digit);
		cout << "expected value:  " << image_label << endl;
		cout << "predicted value: " << predict << endl;
		cout << "cost error:      " << cost_error << endl;
		cout << endl;
	}
	else
	{
		correct++;
	}
  }
  // print results
  cout << "#############################" << endl;
  percentage = (double)(correct) / 10000 * 100.0;
  cout << "correct predictions: " << correct << " / " << 10000 << " = " << percentage << "%" << endl;

  testing_image.close();
  testing_label.close();
  return 0;
}

void read_headers(ifstream &training_image, ifstream &training_label)
{
  // strip headers from training files
  char number;
  for (int i = 0; i < 16; i++)
  {
    training_image.read(&number, sizeof(char));
  }
  for (int i = 0; i < 8; i++)
  {
    training_label.read(&number, sizeof(char));
  }
}

void init_layers(double *&layer_one, double *&layer_two, double *&layer_three)
{
  layer_one = new double[784];
  layer_two = new double[128];
  layer_three = new double[10];
}

void read_weights(string file_name, double **&layer_one_weights, double **&layer_two_weights) 
{
	ifstream training_weights;
	training_weights.open(file_name.c_str(), ios::in);
	
	layer_one_weights = new double *[784]; 
  for (int i = 0; i < 784; i++) 
  {
  	layer_one_weights[i] = new double [128];
    for (int j = 0; j < 128; j++) 
    {
		   training_weights >> layer_one_weights[i][j];
	  }
  }
	
	layer_two_weights = new double *[128]; 
  for (int i = 0; i < 128; i++) 
  {
  	layer_two_weights[i] = new double [10];
    for (int j = 0; j < 10; j++) 
    { 
		   training_weights >> layer_two_weights[i][j];
	  }
  }
	training_weights.close();
}

void read_image(ifstream &image, ifstream &label, int image_digit[28][28], double *layer_one, double expected[], int &image_label)
{
  // read 28x28 binary mnist image
  get_digit(image, image_digit, layer_one);
  // read binary mnist label 
  get_label(label, expected, image_label);
}

void get_digit(ifstream &image, int image_digit[28][28], double *layer_one)
{
  // read 28x28 image one character at a time
  char number;
  for (int j = 0; j < 28; j++)
  {
    for (int i = 0; i < 28; i++)
    {
      int layer_index = i + j * 28;
      image.read(&number, sizeof(char));
      if (number == 0)
      {
 	   		image_digit[i][j] = 0;
      }
      else
      {
        image_digit[i][j] = 1;
      }
      layer_one[layer_index] = image_digit[i][j];
    }
  }
}

void print_digit(int image_digit[28][28])
{
  for (int j = 0; j < 28; j++)
  {
    for (int i = 0; i < 28; i++)
    {
      if (image_digit[i][j] == 0)
      {
      	cout << ".";
      }
      else
      {
      	cout << "@";
      }
    }
    cout << endl;
  }
  cout << endl;
}

void get_label(ifstream &label, double expected[], int &image_label)
{
  // read training label value
  char number;
  label.read(&number, sizeof(char));
  image_label = (int)(number);
  for (int i = 0; i < 10; i++)
  {
    expected[i] = 0.0;
  }
  expected[number] = 1.0;
}

void testing_process(double *layer_one, double *layer_two, double *layer_three,
					 double **layer_one_weights, double **layer_two_weights, int &predict)
{
	perceptron(layer_one, layer_two, layer_three, 
                   layer_one_weights, layer_two_weights);

	// get max value sorting algorithm
	predict = 0;
  for (int i = 1; i < 10; i++) 
  {
		if (layer_three[predict] < layer_three[i]) 
		{
			predict = i;
		}
  }
}

void perceptron(double *layer_one, double *layer_two, double *layer_three,
				double **layer_one_weights, double **layer_two_weights) 
{
	// neural network z values
	double *layer_one_zs, *layer_two_zs; 

	layer_one_zs = new double [128];
  for (int i = 0; i < 128; i++) 
  {
	  layer_one_zs[i] = 0.0;
    for (int j = 0; j < 784; j++) 
    {
        layer_one_zs[i] += layer_one[j] * layer_one_weights[j][i];
	  }
	  // sigmoid z return value
  	layer_two[i] = sigmoid(layer_one_zs[i]);
  }

  layer_two_zs = new double [10];  
	for (int i = 0; i < 10; i++)
  {
    layer_two_zs[i] = 0.0;
    for (int j = 0; j < 128; j++)
    {
      layer_two_zs[i] += layer_two[j] * layer_two_weights[j][i];
    }
	  layer_three[i] = sigmoid(layer_two_zs[i]);
	}
}

double sigmoid(double x)
{
  double sigmoid_value = 0.0;
  sigmoid_value = (1.0 / (1.0 + exp(-x)));
  return sigmoid_value;
}

void cost_value(double *layer_three, double expected[], double &cost_error)
{
  cost_error = 0.0;
  for (int i = 0; i < 10; i++)
  {
    cost_error += (layer_three[i] - expected[i]) * (layer_three[i] - expected[i]);
  }
  cost_error *= 0.5;
}
